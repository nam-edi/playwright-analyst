{% extends 'base.html' %}{% load test_filters %} {% block title %} Playwright
Analyst {% if selected_project %} - {{ selected_project.name }} {% endif %} {%
endblock %} {% load group_users %} {%block content %}

<div id="main-content" class="relative">
  {% if user|has_group:"Admin" or user|has_group:"Manager" %}
  <!-- Bouton Import -->
  <a
    href="/upload/"
    class="absolute top-0 right-0 mt-4 mr-4 inline-flex items-center px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md shadow hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors z-10"
  >
    <svg
      class="w-4 h-4 mr-2"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5m0 0l5-5m-5 5V4"
      />
    </svg>
    Import
  </a>
  {% endif %} {% if selected_project %}
  <div
    class="bg-white rounded-lg shadow-sm border border-gray-200 p-8 text-center"
  >
    <h2 class="text-2xl font-bold text-gray-900 mb-2">
      {{ selected_project.name }}
      <span class="text-gray-500 text-sm">(id: {{ selected_project.id }})</span>
    </h2>
    <p class="text-gray-600 mb-6">
      {{ selected_project.description|default:"Aucune description disponible."
      }}
    </p>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-8">
      <div class="bg-blue-50 rounded-lg p-6">
        <div class="text-3xl font-bold text-blue-600">
          {{ selected_project.executions.count }}
        </div>
        <div class="text-sm text-blue-800 font-medium">
          Exécution{{ selected_project.executions.count|pluralize }}
        </div>
      </div>

      <div class="bg-green-50 rounded-lg p-6">
        <div class="text-3xl font-bold text-green-600">
          {{ selected_project.tests.count }}
        </div>
        <div class="text-sm text-green-800 font-medium">
          Test{{ selected_project.tests.count|pluralize }} unique{{
          selected_project.tests.count|pluralize }}
        </div>
      </div>

      <div class="bg-purple-50 rounded-lg p-6">
        <div class="text-3xl font-bold text-purple-600">
          {{ selected_project.get_unique_tags_count }}
        </div>
        <div class="text-sm text-purple-800 font-medium">
          Tag{{ selected_project.get_unique_tags_count|pluralize }} unique{{
          selected_project.get_unique_tags_count|pluralize }}
        </div>
      </div>
    </div>

    {% if latest_execution and latest_execution_stats %}
    <div class="mt-8 grid grid-cols-1 lg:grid-cols-2 gap-6">
      <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 class="text-xl font-bold text-gray-900 mb-4">
          <a href="{% url 'execution_detail' latest_execution.id %}"
             class="text-gray-900 hover:text-blue-600 transition-colors duration-200 flex items-center group">
            Dernière Exécution
            <svg class="w-4 h-4 ml-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200"
                 fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
            </svg>
          </a>
        </h3>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div>
            <div class="space-y-3">
              <div class="flex items-center gap-2">
                <span class="text-gray-600">Date:</span>
                <span class="font-medium"
                  >{{ latest_execution.start_time|date:"d/m/Y H:i" }}</span
                >
              </div>
              <div class="flex items-center gap-2">
                <span class="text-gray-600">Durée:</span>
                <span class="font-medium"
                  >{{ latest_execution.duration|duration_detailed }}</span
                >
              </div>
              <div class="flex items-center gap-2">
                <span class="text-gray-600">Total tests:</span>
                <span class="font-medium"
                  >{{ latest_execution_stats.total }}</span
                >
              </div>
              {% if latest_execution.git_branch %}
              <div class="flex items-center gap-2">
                <span class="text-gray-600">Branche:</span>
                <span
                  class="font-medium font-mono text-sm bg-gray-100 px-2 py-1 rounded"
                  >{{ latest_execution.git_branch }}</span
                >
              </div>
              {% endif %} {% if latest_execution.git_commit_short_hash %}
              <div class="flex items-center gap-2">
                <span class="text-gray-600">Commit:</span>
                <span
                  class="font-medium font-mono text-sm bg-gray-100 px-2 py-1 rounded"
                  >{{ latest_execution.git_commit_short_hash }}</span
                >
              </div>
              {% endif %}
            </div>
          </div>

          <div class="flex flex-col items-center">
            <div class="relative w-48 h-48 mb-4">
              <canvas id="executionChart" width="192" height="192"></canvas>
            </div>

            <div class="grid grid-cols-2 gap-3 text-sm">
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 bg-green-500 rounded-full"></div>
                <span>PASS: {{ latest_execution_stats.passed }}</span>
              </div>
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 bg-red-500 rounded-full"></div>
                <span>FAIL: {{ latest_execution_stats.failed }}</span>
              </div>
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 bg-yellow-500 rounded-full"></div>
                <span>SKIPPED: {{ latest_execution_stats.skipped }}</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 class="text-lg font-bold text-gray-900 mb-4">
          Évolution du Taux de Réussite
        </h3>
        <div class="relative h-64">
          <canvas id="successRateChart" class="w-full h-full"></canvas>
        </div>
        <div class="mt-2 text-sm text-gray-600 text-center">
          Dernières {{ success_rate_data|length|default:"0" }} exécution{{
          success_rate_data|length|pluralize }}
        </div>
      </div>
    </div>
    {% endif %} {% if selected_project %}
    <div class="mt-8 grid grid-cols-1 lg:grid-cols-2 gap-6">
      <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 class="text-lg font-bold text-gray-900 mb-4">
          Performance dans le Temps
        </h3>
        <div class="relative h-64">
          <canvas id="durationChart" class="w-full h-full"></canvas>
        </div>
        <div class="mt-2 text-sm text-gray-600 text-center">
          Durée d'exécution (secondes)
        </div>
      </div>

      <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
        <h3 class="text-lg font-bold text-gray-900 mb-4">
          Calendrier des Exécutions
        </h3>
        <div class="relative h-64">
          <canvas id="heatmapChart" class="w-full h-full"></canvas>
        </div>
        <div class="mt-2 text-sm text-gray-600 text-center">
          Exécutions du mois en cours
        </div>
      </div>
    </div>
    {% endif %}
  </div>
  {% else %}
  <div
    class="bg-white rounded-lg shadow-sm border border-gray-200 p-8 text-center"
  >
    <div class="mb-4">
      <svg
        class="mx-auto h-16 w-16 text-gray-400"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
        ></path>
      </svg>
    </div>
    <h2 class="text-2xl font-bold text-gray-900 mb-2">
      Aucun projet sélectionné
    </h2>
    <p class="text-gray-600 mb-6">
      Sélectionnez un projet dans le menu déroulant ci-dessus pour commencer
      l'analyse de vos tests Playwright.
    </p>

    {% if not projects %}
    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
      <p class="text-yellow-800">
        <strong>Aucun projet trouvé.</strong>
        Utilisez la commande d'administration pour importer vos résultats de
        tests.
      </p>
    </div>
    {% endif %}
  </div>
  {% endif %}
</div>

{% if latest_execution and latest_execution_stats %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
      const canvas = document.getElementById('executionChart');
      const ctx = canvas.getContext('2d');

      const data = {
          passed: {{ latest_execution_stats.passed }},
          failed: {{ latest_execution_stats.failed }},
          skipped: {{ latest_execution_stats.skipped }},
          flaky: {{ latest_execution_stats.flaky }}
      };

      const colors = {
          passed: '#10b981',
          failed: '#ef4444',
          skipped: '#eab308',
          flaky: '#f97316'
      };

      const total = data.passed + data.failed + data.skipped;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 10;

      let currentAngle = -Math.PI / 2;
      const segments = [];

      function drawSegment(value, color, label) {
          if (value === 0) return;

          const sliceAngle = (value / total) * 2 * Math.PI;
          const startAngle = currentAngle;
          const endAngle = currentAngle + sliceAngle;

          segments.push({
              startAngle,
              endAngle,
              value,
              label,
              color,
              percentage: Math.round((value / total) * 100)
          });

          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();

          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.stroke();

          currentAngle += sliceAngle;
      }

      drawSegment(data.passed, colors.passed, 'Passés');
      drawSegment(data.failed, colors.failed, 'Échoués');
      drawSegment(data.skipped, colors.skipped, 'Ignorés');

      ctx.beginPath();
      ctx.arc(centerX, centerY, radius * 0.6, 0, 2 * Math.PI);
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      ctx.stroke();

      const successRate = total > 0 ? Math.round((data.passed / total) * 100) : 0;
      ctx.fillStyle = '#374151';
      ctx.font = 'bold 24px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(successRate + '%', centerX, centerY - 5);

      ctx.font = '12px system-ui';
      ctx.fillStyle = '#6b7280';
      ctx.fillText('réussite', centerX, centerY + 15);

      const tooltip = document.createElement('div');
      tooltip.style.cssText = `
          position: absolute;
          background: rgba(0,0,0,0.8);
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          pointer-events: none;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.2s;
      `;
      document.body.appendChild(tooltip);

      canvas.addEventListener('mousemove', function(e) {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          let angle = Math.atan2(dy, dx) + Math.PI / 2;
          if (angle < 0) angle += 2 * Math.PI;

          if (distance >= radius * 0.6 && distance <= radius) {
              const segment = segments.find(s => angle >= s.startAngle && angle < s.endAngle);

              if (segment) {
                  canvas.style.cursor = 'pointer';
                  tooltip.innerHTML = `${segment.label}: ${segment.value} (${segment.percentage}%)`;
                  tooltip.style.left = (e.pageX + 5) + 'px';
                  tooltip.style.top = (e.pageY - 30) + 'px';
                  tooltip.style.opacity = '1';
              } else {
                  canvas.style.cursor = 'default';
                  tooltip.style.opacity = '0';
              }
          } else {
              canvas.style.cursor = 'default';
              tooltip.style.opacity = '0';
          }
      });

      canvas.addEventListener('mouseleave', function() {
          canvas.style.cursor = 'default';
          tooltip.style.opacity = '0';
      });
  });
</script>
{% endif %} {% if selected_project %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
      const successCanvas = document.getElementById('successRateChart');
      if (successCanvas) {
          const rect = successCanvas.getBoundingClientRect();
          successCanvas.width = rect.width;
          successCanvas.height = rect.height;

          const successCtx = successCanvas.getContext('2d');

          const successDataRaw = {{ success_rate_data|safe }};
          const successData = successDataRaw.slice().reverse();
          const executions = successData.length;

          if (executions > 0) {
              const padding = 40;
              const chartWidth = successCanvas.width - 2 * padding;
              const chartHeight = successCanvas.height - 2 * padding;

              const points = [];

              successCtx.strokeStyle = '#e5e7eb';
              successCtx.lineWidth = 1;

              for (let i = 0; i <= 10; i++) {
                  const y = padding + (chartHeight * i / 10);
                  successCtx.beginPath();
                  successCtx.moveTo(padding, y);
                  successCtx.lineTo(padding + chartWidth, y);
                  successCtx.stroke();

                  successCtx.fillStyle = '#6b7280';
                  successCtx.font = '10px system-ui';
                  successCtx.textAlign = 'right';
                  successCtx.fillText((100 - i * 10) + '%', padding - 5, y + 3);
              }

              successCtx.beginPath();
              successCtx.moveTo(padding, padding + chartHeight);
              successCtx.lineTo(padding + chartWidth, padding + chartHeight);
              successCtx.stroke();

              successCtx.strokeStyle = '#10b981';
              successCtx.lineWidth = 2;
              successCtx.beginPath();

              for (let i = 0; i < successData.length; i++) {
                  const x = padding + (chartWidth * i / (executions - 1));
                  const y = padding + chartHeight - (chartHeight * successData[i] / 100);

                  points.push({
                      x: x,
                      y: y,
                      value: successData[i],
                      execution: i + 1
                  });

                  if (i === 0) {
                      successCtx.moveTo(x, y);
                  } else {
                      successCtx.lineTo(x, y);
                  }
              }
              successCtx.stroke();

              successCtx.fillStyle = '#10b981';
              for (let i = 0; i < successData.length; i++) {
                  const x = padding + (chartWidth * i / (executions - 1));
                  const y = padding + chartHeight - (chartHeight * successData[i] / 100);

                  successCtx.beginPath();
                  successCtx.arc(x, y, 3, 0, 2 * Math.PI);
                  successCtx.fill();
              }

              const successTooltip = document.createElement('div');
              successTooltip.style.cssText = `
                  position: absolute;
                  background: rgba(0,0,0,0.8);
                  color: white;
                  padding: 8px 12px;
                  border-radius: 4px;
                  font-size: 12px;
                  pointer-events: none;
                  z-index: 1000;
                  opacity: 0;
                  transition: opacity 0.2s;
              `;
              document.body.appendChild(successTooltip);

              successCanvas.addEventListener('mousemove', function(e) {
                  const rect = successCanvas.getBoundingClientRect();
                  const mouseX = e.clientX - rect.left;
                  const mouseY = e.clientY - rect.top;

                  let closestPoint = null;
                  let minDistance = Infinity;

                  points.forEach(point => {
                      const distance = Math.sqrt(Math.pow(mouseX - point.x, 2) + Math.pow(mouseY - point.y, 2));
                      if (distance < 15 && distance < minDistance) {
                          minDistance = distance;
                          closestPoint = point;
                      }
                  });

                  if (closestPoint) {
                      successCanvas.style.cursor = 'pointer';
                      successTooltip.innerHTML = `Exécution #${closestPoint.execution}<br>Taux de réussite: ${closestPoint.value}%`;
                      successTooltip.style.left = (e.pageX + 5) + 'px';
                      successTooltip.style.top = (e.pageY - 30) + 'px';
                      successTooltip.style.opacity = '1';
                  } else {
                      successCanvas.style.cursor = 'default';
                      successTooltip.style.opacity = '0';
                  }
              });

              successCanvas.addEventListener('mouseleave', function() {
                  successCanvas.style.cursor = 'default';
                  successTooltip.style.opacity = '0';
              });
          } else {
              successCtx.fillStyle = '#6b7280';
              successCtx.font = '14px system-ui';
              successCtx.textAlign = 'center';
              successCtx.fillText('Aucune donnée disponible', successCanvas.width / 2, successCanvas.height / 2);
          }
      }

      const durationCanvas = document.getElementById('durationChart');
      if (durationCanvas) {
          const rect = durationCanvas.getBoundingClientRect();
          durationCanvas.width = rect.width;
          durationCanvas.height = rect.height;

          const durationCtx = durationCanvas.getContext('2d');

          const durationDataRaw = {{ duration_data|safe }};
          const durationData = durationDataRaw.slice().reverse();

          if (durationData.length > 0) {
              const padding = 40;
              const chartWidth = durationCanvas.width - 2 * padding;
              const chartHeight = durationCanvas.height - 2 * padding;
              const maxDuration = Math.max(...durationData);
              const minDuration = Math.min(...durationData);

              const adjustedMinDuration = 0;
              const durationRange = maxDuration - adjustedMinDuration;

              const bars = [];

              durationCtx.strokeStyle = '#e5e7eb';
              durationCtx.lineWidth = 1;

              for (let i = 0; i <= 5; i++) {
                  const y = padding + (chartHeight * i / 5);
                  durationCtx.beginPath();
                  durationCtx.moveTo(padding, y);
                  durationCtx.lineTo(padding + chartWidth, y);
                  durationCtx.stroke();

                  const value = maxDuration - (durationRange * i / 5);
                  durationCtx.fillStyle = '#6b7280';
                  durationCtx.font = '10px system-ui';
                  durationCtx.textAlign = 'right';
                  durationCtx.fillText(Math.round(value/1000) + 's', padding - 5, y + 3);
              }

              const barWidth = chartWidth / durationData.length * 0.6;
              durationCtx.fillStyle = '#3b82f6';

              for (let i = 0; i < durationData.length; i++) {
                  const x = padding + (chartWidth * i / durationData.length) + (chartWidth / durationData.length - barWidth) / 2;

                  const normalizedHeight = (durationData[i] - adjustedMinDuration) / durationRange * chartHeight;
                  const y = padding + chartHeight - normalizedHeight;

                  bars.push({
                      x: x,
                      y: y,
                      width: barWidth,
                      height: normalizedHeight,
                      duration: durationData[i],
                      execution: i + 1
                  });

                  durationCtx.fillRect(x, y, barWidth, normalizedHeight);

                  durationCtx.strokeStyle = '#1e40af';
                  durationCtx.lineWidth = 1;
                  durationCtx.strokeRect(x, y, barWidth, normalizedHeight);
              }

              const durationTooltip = document.createElement('div');
              durationTooltip.style.cssText = `
                  position: absolute;
                  background: rgba(0,0,0,0.8);
                  color: white;
                  padding: 8px 12px;
                  border-radius: 4px;
                  font-size: 12px;
                  pointer-events: none;
                  z-index: 1000;
                  opacity: 0;
                  transition: opacity 0.2s;
              `;
              document.body.appendChild(durationTooltip);

              durationCanvas.addEventListener('mousemove', function(e) {
                  const rect = durationCanvas.getBoundingClientRect();
                  const mouseX = e.clientX - rect.left;
                  const mouseY = e.clientY - rect.top;

                  const hoveredBar = bars.find(bar =>
                      mouseX >= bar.x &&
                      mouseX <= bar.x + bar.width &&
                      mouseY >= bar.y &&
                      mouseY <= bar.y + bar.height
                  );

                  if (hoveredBar) {
                      durationCanvas.style.cursor = 'pointer';
                      const seconds = (hoveredBar.duration / 1000).toFixed(1);
                      const minutes = Math.floor(hoveredBar.duration / 60000);
                      const remainingSeconds = ((hoveredBar.duration % 60000) / 1000).toFixed(1);

                      let timeDisplay = seconds < 60 ?
                          `${seconds}s` :
                          `${minutes}m ${remainingSeconds}s`;

                      durationTooltip.innerHTML = `Exécution #${hoveredBar.execution}<br>Durée: ${timeDisplay}`;
                      durationTooltip.style.left = (e.pageX + 5) + 'px';
                      durationTooltip.style.top = (e.pageY - 30) + 'px';
                      durationTooltip.style.opacity = '1';
                  } else {
                      durationCanvas.style.cursor = 'default';
                      durationTooltip.style.opacity = '0';
                  }
              });

              durationCanvas.addEventListener('mouseleave', function() {
                  durationCanvas.style.cursor = 'default';
                  durationTooltip.style.opacity = '0';
              });
          } else {
              durationCtx.fillStyle = '#6b7280';
              durationCtx.font = '14px system-ui';
              durationCtx.textAlign = 'center';
              durationCtx.fillText('Aucune donnée disponible', durationCanvas.width / 2, durationCanvas.height / 2);
          }
      }

      const heatmapCanvas = document.getElementById('heatmapChart');
      if (heatmapCanvas) {
          const rect = heatmapCanvas.getBoundingClientRect();
          heatmapCanvas.width = rect.width;
          heatmapCanvas.height = rect.height;

          const heatmapCtx = heatmapCanvas.getContext('2d');

          const heatmapData = {{ heatmap_data|safe }};

          if (heatmapData.length > 0) {
              const today = new Date();
              const currentMonth = today.getMonth();
              const currentYear = today.getFullYear();

              const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
              const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);

              const daysInMonth = lastDayOfMonth.getDate();
              const firstDayOfWeek = firstDayOfMonth.getDay();

              const totalCells = firstDayOfWeek + daysInMonth;
              const rows = Math.ceil(totalCells / 7);

              const cellSize = Math.min(28, (heatmapCanvas.width - 80) / 7 - 3);
              const cellGap = 3;
              const cols = 7;

              const startX = (heatmapCanvas.width - (cols * (cellSize + cellGap) - cellGap)) / 2;
              const startY = 80;

              const monthNames = ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
                               'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'];
              heatmapCtx.fillStyle = '#374151';
              heatmapCtx.font = 'bold 16px system-ui';
              heatmapCtx.textAlign = 'center';
              heatmapCtx.fillText(`${monthNames[currentMonth]} ${currentYear}`, heatmapCanvas.width / 2, 30);

              const dayLabels = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
              heatmapCtx.fillStyle = '#6b7280';
              heatmapCtx.font = '12px system-ui';
              heatmapCtx.textAlign = 'center';

              for (let i = 0; i < dayLabels.length; i++) {
                  const x = startX + i * (cellSize + cellGap) + cellSize / 2;
                  heatmapCtx.fillText(dayLabels[i], x, startY - 15);
              }

              const maxCount = Math.max(...heatmapData.map(d => d.count));

              const calendarCells = [];

              for (let row = 0; row < rows; row++) {
                  for (let col = 0; col < 7; col++) {
                      const cellIndex = row * 7 + col;
                      const dayOfMonth = cellIndex - firstDayOfWeek + 1;

                      const x = startX + col * (cellSize + cellGap);
                      const y = startY + row * (cellSize + cellGap);

                      if (dayOfMonth >= 1 && dayOfMonth <= daysInMonth) {
                          const currentDate = new Date(currentYear, currentMonth, dayOfMonth);
                          // Utiliser une date locale au lieu de UTC
                          const year = currentDate.getFullYear();
                          const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                          const day = String(currentDate.getDate()).padStart(2, '0');
                          const dateStr = `${year}-${month}-${day}`;
                          const dayData = heatmapData.find(d => d.date === dateStr);
                          const count = dayData ? dayData.count : 0;

                          calendarCells.push({
                              x: x,
                              y: y,
                              width: cellSize,
                              height: cellSize,
                              date: currentDate,
                              count: count,
                              dayOfMonth: dayOfMonth
                          });

                          const intensity = maxCount > 0 ? count / maxCount : 0;
                          const alpha = count > 0 ? Math.max(0.2, intensity) : 0.05;

                          const isToday = dayOfMonth === today.getDate() &&
                                        currentMonth === today.getMonth() &&
                                        currentYear === today.getFullYear();

                          if (isToday) {
                              heatmapCtx.fillStyle = `rgba(59, 130, 246, 0.3)`;
                          } else {
                              heatmapCtx.fillStyle = `rgba(16, 185, 129, ${alpha})`;
                          }

                          heatmapCtx.fillRect(x, y, cellSize, cellSize);

                          if (isToday) {
                              heatmapCtx.strokeStyle = '#3b82f6';
                              heatmapCtx.lineWidth = 2;
                          } else {
                              heatmapCtx.strokeStyle = '#e5e7eb';
                              heatmapCtx.lineWidth = 1;
                          }
                          heatmapCtx.strokeRect(x, y, cellSize, cellSize);

                          heatmapCtx.fillStyle = isToday ? '#1f2937' : '#374151';
                          heatmapCtx.font = '11px system-ui';
                          heatmapCtx.textAlign = 'center';
                          heatmapCtx.fillText(dayOfMonth.toString(), x + cellSize / 2, y + cellSize / 2 + 4);

                          if (count > 0) {
                              heatmapCtx.fillStyle = '#059669';
                              heatmapCtx.font = 'bold 8px system-ui';
                              heatmapCtx.fillText(count.toString(), x + cellSize - 8, y + 12);
                          }
                      } else {
                          heatmapCtx.fillStyle = 'rgba(249, 250, 251, 0.5)';
                          heatmapCtx.fillRect(x, y, cellSize, cellSize);
                          heatmapCtx.strokeStyle = '#f3f4f6';
                          heatmapCtx.lineWidth = 1;
                          heatmapCtx.strokeRect(x, y, cellSize, cellSize);
                      }
                  }
              }

              const calendarTooltip = document.createElement('div');
              calendarTooltip.style.cssText = `
                  position: absolute;
                  background: rgba(0,0,0,0.8);
                  color: white;
                  padding: 8px 12px;
                  border-radius: 4px;
                  font-size: 12px;
                  pointer-events: none;
                  z-index: 1000;
                  opacity: 0;
                  transition: opacity 0.2s;
              `;
              document.body.appendChild(calendarTooltip);

              heatmapCanvas.addEventListener('mousemove', function(e) {
                  const rect = heatmapCanvas.getBoundingClientRect();
                  const mouseX = e.clientX - rect.left;
                  const mouseY = e.clientY - rect.top;

                  const hoveredCell = calendarCells.find(cell =>
                      mouseX >= cell.x &&
                      mouseX <= cell.x + cell.width &&
                      mouseY >= cell.y &&
                      mouseY <= cell.y + cell.height
                  );

                  if (hoveredCell) {
                      heatmapCanvas.style.cursor = 'pointer';

                      const dayNames = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
                      const dayName = dayNames[hoveredCell.date.getDay()];
                      const formattedDate = hoveredCell.date.toLocaleDateString('fr-FR', {
                          day: 'numeric',
                          month: 'long'
                      });

                      const executionText = hoveredCell.count === 0 ? 'Aucune exécution' :
                                          hoveredCell.count === 1 ? '1 exécution' :
                                          `${hoveredCell.count} exécutions`;

                      calendarTooltip.innerHTML = `${dayName} ${formattedDate}<br>${executionText}`;
                      calendarTooltip.style.left = (e.pageX + 5) + 'px';
                      calendarTooltip.style.top = (e.pageY - 30) + 'px';
                      calendarTooltip.style.opacity = '1';
                  } else {
                      heatmapCanvas.style.cursor = 'default';
                      calendarTooltip.style.opacity = '0';
                  }
              });

              heatmapCanvas.addEventListener('mouseleave', function() {
                  heatmapCanvas.style.cursor = 'default';
                  calendarTooltip.style.opacity = '0';
              });
              const legendY = startY + rows * (cellSize + cellGap) + 30;
              heatmapCtx.fillStyle = '#6b7280';
              heatmapCtx.font = '12px system-ui';
              heatmapCtx.textAlign = 'left';
              heatmapCtx.fillText('Moins', startX, legendY);

              for (let i = 0; i < 5; i++) {
                  const x = startX + 50 + i * (cellSize * 0.8 + 2);
                  const y = legendY - 15;
                  const alpha = i === 0 ? 0.05 : Math.max(0.2, i / 4);
                  heatmapCtx.fillStyle = `rgba(16, 185, 129, ${alpha})`;
                  heatmapCtx.fillRect(x, y, cellSize * 0.8, cellSize * 0.8);
                  heatmapCtx.strokeStyle = '#e5e7eb';
                  heatmapCtx.strokeRect(x, y, cellSize * 0.8, cellSize * 0.8);
              }

              heatmapCtx.fillStyle = '#6b7280';
              heatmapCtx.fillText('Plus', startX + 50 + 5 * (cellSize * 0.8 + 2) + 10, legendY);
          } else {
              heatmapCtx.fillStyle = '#6b7280';
              heatmapCtx.font = '14px system-ui';
              heatmapCtx.textAlign = 'center';
              heatmapCtx.fillText('Aucune donnée disponible', heatmapCanvas.width / 2, heatmapCanvas.height / 2);
          }
      }
  });
</script>
{% endif %} {% if selected_project and latest_execution %}
<div class="mt-8">
  <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
    <div class="flex items-center justify-between mb-6">
      <h3 class="text-lg font-bold text-gray-900">
        <svg
          class="w-5 h-5 text-amber-500 inline mr-2"
          fill="currentColor"
          viewBox="0 0 20 20"
        >
          <path
            fill-rule="evenodd"
            d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
            clip-rule="evenodd"
          ></path>
        </svg>
        Tests Instables (<span id="flaky-tests-count">{{ flaky_tests|length }}</span>)
      </h3>
      <div class="flex items-center space-x-4">
        <div class="text-sm text-gray-500">
          Tests avec des tentatives répétées
        </div>
        <!-- Sélecteur d'exécution -->
        <div class="relative">
          <select
            id="flaky-execution-selector"
            class="appearance-none bg-white border border-gray-300 rounded-md px-3 py-1 text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            onchange="updateFlakyTests(this.value)"
          >
            {% for execution in recent_executions %}
            <option
              value="{{ execution.id }}"
              {% if execution.id == latest_execution.id %}selected{% endif %}
            >
              {% if execution.raw_json.config.metadata.name or execution.raw_json.config.metadata.environment %}
                {% if execution.raw_json.config.metadata.name %}{{ execution.raw_json.config.metadata.name }}{% endif %}{% if execution.raw_json.config.metadata.name and execution.raw_json.config.metadata.environment %} - {% endif %}{% if execution.raw_json.config.metadata.environment %}{{ execution.raw_json.config.metadata.environment }}{% endif %} - {{ execution.start_time|date:"d/m/Y H:i" }}
              {% else %}
                {{ execution.start_time|date:"d/m/Y H:i" }}
              {% endif %}
              {% if execution.git_branch %} ({{ execution.git_branch }}){% endif %}
            </option>
            {% endfor %}
          </select>
          <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
            <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
              <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
            </svg>
          </div>
        </div>
      </div>
    </div>

    <!-- Conteneur pour les tests instables (sera mis à jour via AJAX) -->
    <div id="flaky-tests-container">
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {% for test in flaky_tests %}
      <a
        href="{% url 'tests_list' %}?search={{ test.title|urlencode }}"
        class="block border border-amber-200 bg-amber-50 rounded-lg p-4 hover:bg-amber-100 hover:border-amber-300 transition-all cursor-pointer"
      >
        <div class="flex items-start justify-between mb-2">
          <div class="flex-1 min-w-0">
            <h4
              class="text-sm font-medium text-gray-900 truncate hover:text-amber-700"
              title="{{ test.title }}"
            >
              {{ test.title|truncatechars:50 }}
            </h4>
            <p
              class="text-xs text-gray-600 mt-1 truncate"
              title="{{ test.file_path }}"
            >
              📁 {{ test.file_path|truncatechars:40 }}
            </p>
          </div>
          <div class="flex items-center text-amber-600 ml-2">
            <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path
                fill-rule="evenodd"
                d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z"
                clip-rule="evenodd"
              ></path>
            </svg>
            <span class="text-sm font-medium">{{ test.retry_count }}</span>
          </div>
        </div>

        <div class="flex items-center justify-between text-xs text-gray-500">
          <div class="flex items-center">
            <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
              <path
                fill-rule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z"
                clip-rule="evenodd"
              ></path>
            </svg>
            {{ test.duration|duration_detailed }}
          </div>
          <div class="flex items-center">
            {% if test.retry_count == 1 %}
            <span
              class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-yellow-100 text-yellow-800"
            >
              1 retry
            </span>
            {% elif test.retry_count <= 3 %}
            <span
              class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-orange-100 text-orange-800"
            >
              {{ test.retry_count }} retries
            </span>
            {% else %}
            <span
              class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800"
            >
              {{ test.retry_count }} retries
            </span>
            {% endif %}
          </div>
        </div>

        {% if test.line %}
        <div class="mt-2 text-xs text-gray-400">
          Ligne {{ test.line }}{% if test.column %}, col {{ test.column }}{%
          endif %}
        </div>
        {% endif %}
      </a>
      {% empty %}
      <div class="col-span-full text-center py-8 text-gray-500">
        <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <p class="text-lg font-medium">Aucun test instable trouvé</p>
        <p class="text-sm mt-1">Cette exécution ne contient aucun test ayant nécessité des tentatives répétées.</p>
      </div>
      {% endfor %}
      </div>
    </div>

    <div
      class="mt-4 text-xs text-gray-500 bg-amber-50 border border-amber-200 rounded p-3"
    >
      <div class="flex items-start">
        <svg
          class="w-4 h-4 text-amber-500 mr-2 mt-0.5 flex-shrink-0"
          fill="currentColor"
          viewBox="0 0 20 20"
        >
          <path
            fill-rule="evenodd"
            d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
            clip-rule="evenodd"
          ></path>
        </svg>
        <div>
          <strong>Tests instables :</strong> Ces tests ont échoué au moins une
          fois avant de réussir. Ils peuvent indiquer des problèmes de timing,
          de flakiness ou de synchronisation. Sélectionnez une exécution différente ci-dessus pour voir les tests instables d'autres exécutions.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Script pour la gestion du changement d'exécution -->
<script>
function updateFlakyTests(executionId) {
    if (!executionId) return;

    const container = document.getElementById('flaky-tests-container');
    const countElement = document.getElementById('flaky-tests-count');
    const originalContent = container.innerHTML;

    // Afficher un loader
    container.innerHTML = `
        <div class="flex items-center justify-center py-8">
            <div class="flex items-center space-x-2">
                <svg class="animate-spin h-5 w-5 text-amber-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="text-sm text-gray-600">Chargement des tests instables...</span>
            </div>
        </div>
    `;

    // Faire la requête AJAX
    fetch(`/api/flaky-tests/${executionId}/`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Erreur lors du chargement des données');
            }
            return response.json();
        })
        .then(data => {
            // Mettre à jour le compteur
            countElement.textContent = data.flaky_tests ? data.flaky_tests.length : 0;

            // Construire le HTML des tests instables
            if (data.flaky_tests && data.flaky_tests.length > 0) {
                let html = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';

                data.flaky_tests.forEach(test => {
                    let retryBadgeClass = 'bg-yellow-100 text-yellow-800';
                    if (test.retry_count > 3) {
                        retryBadgeClass = 'bg-red-100 text-red-800';
                    } else if (test.retry_count > 1) {
                        retryBadgeClass = 'bg-orange-100 text-orange-800';
                    }

                    let retryText = test.retry_count === 1 ? '1 retry' : `${test.retry_count} retries`;
                    let locationText = '';
                    if (test.line) {
                        locationText = `<div class="mt-2 text-xs text-gray-400">Ligne ${test.line}`;
                        if (test.column) {
                            locationText += `, col ${test.column}`;
                        }
                        locationText += '</div>';
                    }

                    html += `
                        <a href="/tests/?search=${encodeURIComponent(test.title)}"
                           class="block border border-amber-200 bg-amber-50 rounded-lg p-4 hover:bg-amber-100 hover:border-amber-300 transition-all cursor-pointer">
                            <div class="flex items-start justify-between mb-2">
                                <div class="flex-1 min-w-0">
                                    <h4 class="text-sm font-medium text-gray-900 truncate hover:text-amber-700"
                                        title="${test.title}">
                                        ${test.title.length > 50 ? test.title.substring(0, 50) + '...' : test.title}
                                    </h4>
                                    <p class="text-xs text-gray-600 mt-1 truncate"
                                       title="${test.file_path}">
                                        📁 ${test.file_path.length > 40 ? test.file_path.substring(0, 40) + '...' : test.file_path}
                                    </p>
                                </div>
                                <div class="flex items-center text-amber-600 ml-2">
                                    <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd"></path>
                                    </svg>
                                    <span class="text-sm font-medium">${test.retry_count}</span>
                                </div>
                            </div>
                            <div class="flex items-center justify-between text-xs text-gray-500">
                                <div class="flex items-center">
                                    <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                                    </svg>
                                    ${formatDuration(test.duration)}
                                </div>
                                <div class="flex items-center">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${retryBadgeClass}">
                                        ${retryText}
                                    </span>
                                </div>
                            </div>
                            ${locationText}
                        </a>
                    `;
                });

                html += '</div>';
                container.innerHTML = html;
            } else {
                // Aucun test instable trouvé
                container.innerHTML = `
                    <div class="text-center py-8 text-gray-500">
                        <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <p class="text-lg font-medium">Aucun test instable trouvé</p>
                        <p class="text-sm mt-1">Cette exécution ne contient aucun test ayant nécessité des tentatives répétées.</p>
                    </div>
                `;
            }
        })
        .catch(error => {
            console.error('Erreur:', error);
            // Restaurer le contenu original en cas d'erreur
            container.innerHTML = originalContent;
            alert('Erreur lors du chargement des tests instables. Veuillez réessayer.');
        });
}

// Fonction utilitaire pour formater la durée
function formatDuration(duration) {
    if (duration < 1000) {
        return duration + 'ms';
    } else if (duration < 60000) {
        return (duration / 1000).toFixed(1) + 's';
    } else {
        const minutes = Math.floor(duration / 60000);
        const seconds = ((duration % 60000) / 1000).toFixed(1);
        return minutes + 'm ' + seconds + 's';
    }
}
</script>
{% endif %} {% if selected_project and tags_map_data %}
<div class="mt-8">
  <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
    <div class="flex items-center justify-between mb-6">
      <h3 class="text-lg font-bold text-gray-900">
        Cartographie des Tests par Tags
      </h3>
      <div class="flex items-center space-x-4">
        <div class="flex items-center space-x-4 text-sm text-gray-600">
          <div class="flex items-center">
            <div class="w-3 h-3 bg-green-500 rounded-full mr-2"></div>
            <span>Taille = Nombre de tests</span>
          </div>
          <div class="flex items-center">
            <div class="w-8 h-0.5 bg-gray-400 mr-2"></div>
            <span>Liens = Tests partagés</span>
          </div>
        </div>
        <div class="flex items-center space-x-2">
          <button
            id="zoom-in-btn"
            class="px-2 py-1 text-xs bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors duration-200"
            title="Zoom avant"
          >
            <svg
              class="w-3 h-3"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 6v6m0 0v6m0-6h6m-6 0H6"
              ></path>
            </svg>
          </button>
          <button
            id="zoom-out-btn"
            class="px-2 py-1 text-xs bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors duration-200"
            title="Zoom arrière"
          >
            <svg
              class="w-3 h-3"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M18 12H6"
              ></path>
            </svg>
          </button>
          <button
            id="fullscreen-btn"
            class="px-3 py-1 text-xs bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors duration-200 flex items-center"
            title="Afficher en plein écran"
          >
            <svg
              class="w-3 h-3 mr-1"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
              ></path>
            </svg>
            Plein écran
          </button>
          <button
            id="reset-view-btn"
            class="hidden px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors duration-200 flex items-center"
            title="Revenir à la vue d'origine"
          >
            <svg
              class="w-3 h-3 mr-1"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
              ></path>
            </svg>
            Reset View
          </button>
        </div>
      </div>
    </div>

    <!-- Conteneur pour le graphique D3.js -->
    <div id="tags-network-chart" class="w-full" style="height: 500px"></div>

    <!-- Modal plein écran -->
    <div
      id="fullscreen-modal"
      class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden flex items-center justify-center"
    >
      <div
        class="bg-white rounded-lg shadow-2xl w-full h-full m-2 flex flex-col"
      >
        <!-- En-tête de la modal -->
        <div
          class="flex items-center justify-between p-4 border-b border-gray-200 flex-shrink-0"
        >
          <h3 class="text-lg font-semibold text-gray-900">
            Cartographie des Tests par Tags - Vue étendue
          </h3>
          <div class="flex items-center space-x-2">
            <!-- Boutons de contrôle pour la modal -->
            <button
              id="modal-zoom-in-btn"
              class="px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors duration-200 flex items-center"
              title="Zoom +"
            >
              <svg
                class="w-3 h-3 mr-1"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M12 6v6m0 0v6m0-6h6m-6 0H6"
                ></path>
              </svg>
            </button>
            <button
              id="modal-zoom-out-btn"
              class="px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors duration-200 flex items-center"
              title="Zoom -"
            >
              <svg
                class="w-3 h-3 mr-1"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M18 12H6"
                ></path>
              </svg>
            </button>
            <button
              id="modal-reset-view-btn"
              class="hidden px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors duration-200 flex items-center"
              title="Revenir à la vue d'origine"
            >
              <svg
                class="w-3 h-3 mr-1"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                ></path>
              </svg>
              Reset
            </button>
            <!-- Bouton de fermeture -->
            <button
              id="close-modal-btn"
              class="px-3 py-1 text-xs bg-red-600 text-white rounded hover:bg-red-700 transition-colors duration-200 flex items-center"
              title="Fermer"
            >
              <svg
                class="w-3 h-3 mr-1"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M6 18L18 6M6 6l12 12"
                ></path>
              </svg>
              Fermer
            </button>
          </div>
        </div>

        <!-- Contenu de la modal -->
        <div class="flex-1 p-4">
          <div
            id="tags-network-chart-modal"
            class="w-full h-full border border-gray-200 rounded"
          ></div>
        </div>
      </div>
    </div>

    <!-- Légende -->
    <div class="mt-4 p-4 bg-gray-50 rounded-lg">
      <h4 class="font-semibold text-gray-900 mb-3">Statistiques détaillées</h4>
      <div
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3"
        id="tags-legend"
      >
        <!-- Sera rempli dynamiquement par JavaScript -->
      </div>
    </div>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
      const tagsData = {{ tags_map_data|safe }};
      const linksData = {{ tags_links_data|safe }};

      if (tagsData.length === 0) {
          document.getElementById('tags-network-chart').innerHTML = `
              <div class="flex flex-col items-center justify-center h-full text-gray-500">
                  <svg class="w-16 h-16 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.99 1.99 0 013 12V7a4 4 0 014-4z">
                      </path>
                  </svg>
                  <p class="text-lg">Aucun tag trouvé pour ce projet.</p>
                  <p class="text-sm mt-1">Les tags sont automatiquement créés lors de l'importation des résultats de tests.</p>
              </div>
          `;
          return;
      }

      // Configuration du graphique
      const container = document.getElementById('tags-network-chart');
      const width = container.clientWidth;
      const height = 500;

      // Nettoyer le conteneur
      d3.select('#tags-network-chart').selectAll('*').remove();

      // Créer le SVG
      const svg = d3.select('#tags-network-chart')
          .append('svg')
          .attr('width', width)
          .attr('height', height);

      // Créer un groupe pour le zoom
      const g = svg.append('g');

      // Configuration des couleurs et échelles
      const maxTests = d3.max(tagsData, d => d.total_tests);
      const radiusScale = d3.scaleSqrt()
          .domain([1, maxTests])
          .range([20, 80]);

      const linkStrengthScale = d3.scaleLinear()
          .domain([1, d3.max(linksData, d => d.value) || 1])
          .range([0.1, 1]);

      // Analyser la connectivité pour optimiser le placement
      const nodeConnectivity = new Map();
      tagsData.forEach(node => {
          const connections = linksData.filter(link =>
              link.source === node.id || link.target === node.id
          );
          nodeConnectivity.set(node.id, {
              count: connections.length,
              totalWeight: connections.reduce((sum, link) => sum + link.value, 0)
          });
      });

      // Trier les nœuds par importance (connectivité + poids)
      const sortedNodes = [...tagsData].sort((a, b) => {
          const aConnectivity = nodeConnectivity.get(a.id);
          const bConnectivity = nodeConnectivity.get(b.id);
          const aScore = aConnectivity.count * 2 + aConnectivity.totalWeight + a.total_tests;
          const bScore = bConnectivity.count * 2 + bConnectivity.totalWeight + b.total_tests;
          return bScore - aScore;
      });

      // Préparer les données pour D3 avec positionnement optimisé
      const nodes = sortedNodes.map((d, i) => {
          let x, y;

          // Algorithme de placement en cercles concentriques pour réduire les croisements
          const connectivity = nodeConnectivity.get(d.id);
          const totalNodes = sortedNodes.length;

          if (i === 0) {
              // Le nœud le plus connecté au centre
              x = width / 2;
              y = height / 2;
          } else if (i <= 3 && totalNodes > 4) {
              // Les 3 suivants en cercle proche du centre
              const angle = ((i - 1) / 3) * 2 * Math.PI;
              const radius = Math.min(width, height) / 8;
              x = width / 2 + Math.cos(angle) * radius;
              y = height / 2 + Math.sin(angle) * radius;
          } else {
              // Les autres en cercles concentriques selon leur connectivité
              const remainingNodes = totalNodes - 4;
              const nodeIndex = i - 4;
              const connectivityRatio = connectivity.count / Math.max(...Array.from(nodeConnectivity.values()).map(c => c.count));

              // Rayon basé sur la connectivité (moins connecté = plus loin)
              const baseRadius = Math.min(width, height) / 6;
              const maxRadius = Math.min(width, height) / 3;
              const radius = baseRadius + (maxRadius - baseRadius) * (1 - connectivityRatio);

              // Angle distribué pour éviter les superpositions
              const angle = (nodeIndex / Math.max(remainingNodes, 1)) * 2 * Math.PI;

              // Ajouter une petite variation aléatoire pour éviter l'alignement parfait
              const angleVariation = (Math.random() - 0.5) * 0.3;
              const radiusVariation = (Math.random() - 0.5) * 20;

              x = width / 2 + Math.cos(angle + angleVariation) * (radius + radiusVariation);
              y = height / 2 + Math.sin(angle + angleVariation) * (radius + radiusVariation);
          }

          return {
              id: d.id,
              name: d.name,
              color: d.color,
              total_tests: d.total_tests,
              passed_count: d.passed_count,
              failed_count: d.failed_count,
              skipped_count: d.skipped_count,
              flaky_count: d.flaky_count,
              success_rate: d.success_rate,
              radius: radiusScale(d.total_tests),
              x: x,
              y: y,
              connectivity: connectivity.count,
              importance: connectivity.count * 2 + connectivity.totalWeight + d.total_tests
          };
      });

      const links = linksData.map(d => ({
          source: d.source,
          target: d.target,
          value: d.value,
          strength: linkStrengthScale(d.value)
      }));

      // Créer la simulation de force optimisée pour réduire les croisements
      const simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(d => d.id)
              .strength(d => {
                  // Force de lien adaptée : plus forte pour les liens importants
                  const baseStrength = d.strength;
                  const sourceNode = nodes.find(n => n.id === d.source.id || n.id === d.source);
                  const targetNode = nodes.find(n => n.id === d.target.id || n.id === d.target);
                  if (sourceNode && targetNode) {
                      // Liens entre nœuds très connectés = force plus faible pour éviter la compression
                      const connectivityFactor = 1 - (sourceNode.connectivity + targetNode.connectivity) / 20;
                      return baseStrength * Math.max(connectivityFactor, 0.1);
                  }
                  return baseStrength;
              })
              .distance(d => {
                  // Distance adaptée selon l'importance des nœuds
                  const sourceNode = nodes.find(n => n.id === d.source.id || n.id === d.source);
                  const targetNode = nodes.find(n => n.id === d.target.id || n.id === d.target);
                  if (sourceNode && targetNode) {
                      const avgRadius = (sourceNode.radius + targetNode.radius) / 2;
                      const connectivityBonus = (sourceNode.connectivity + targetNode.connectivity) * 5;
                      return avgRadius * 3 + connectivityBonus + 30;
                  }
                  return 50;
              })
          )
          .force('charge', d3.forceManyBody()
              .strength(d => {
                  // Force de répulsion adaptée à l'importance du nœud
                  const baseStrength = -800;
                  const connectivityMultiplier = 1 + d.connectivity * 0.1;
                  const sizeMultiplier = 1 + d.radius / 50;
                  return baseStrength * connectivityMultiplier * sizeMultiplier;
              })
          )
          .force('center', d3.forceCenter(width / 2, height / 2).strength(0.1)) // Force de centrage réduite
          .force('collision', d3.forceCollide()
              .radius(d => d.radius + 15 + d.connectivity * 2) // Espace proportionnel à la connectivité
              .strength(0.8)
          )
          // Force radiale pour maintenir la structure en cercles concentriques
          .force('radial', d3.forceRadial()
              .radius(d => {
                  // Rayon basé sur l'importance : nœuds importants au centre
                  const maxImportance = Math.max(...nodes.map(n => n.importance));
                  const importanceRatio = d.importance / maxImportance;
                  const minRadius = Math.min(width, height) / 8;
                  const maxRadius = Math.min(width, height) / 3;
                  return minRadius + (maxRadius - minRadius) * (1 - importanceRatio);
              })
              .x(width / 2)
              .y(height / 2)
              .strength(0.2)
          );

      // Sauvegarder les positions initiales
      let initialPositionsSaved = false;
      const initialPositions = new Map();

      // Fonction pour sauvegarder les positions initiales
      function saveInitialPositions() {
          if (!initialPositionsSaved) {
              nodes.forEach(node => {
                  initialPositions.set(node.id, { x: node.x, y: node.y });
              });
              initialPositionsSaved = true;
              console.log('Positions initiales sauvegardées:', initialPositions);
          }
      }

      // Dessiner les liens
      const link = g.append('g')
          .selectAll('line')
          .data(links)
          .enter()
          .append('line')
          .attr('stroke', '#999')
          .attr('stroke-opacity', 0.6)
          .attr('stroke-width', d => Math.sqrt(d.value) + 1);

      // Créer les groupes pour les nœuds
      const node = g.append('g')
          .selectAll('g')
          .data(nodes)
          .enter()
          .append('g')
          .attr('class', 'node')
          .style('cursor', 'pointer')
          .call(d3.drag()
              .on('start', dragstarted)
              .on('drag', dragged)
              .on('end', dragended));

      // Dessiner les cercles principaux
      const circles = node.append('circle')
          .attr('r', d => d.radius)
          .attr('fill', d => d.color)
          .attr('stroke', '#fff')
          .attr('stroke-width', 3)
          .style('filter', 'drop-shadow(2px 2px 4px rgba(0,0,0,0.1))');

      // Ajouter les labels
      const labels = node.append('text')
          .attr('text-anchor', 'middle')
          .attr('dy', '0.35em')
          .style('font-size', d => Math.min(d.radius / 3, 14) + 'px')
          .style('font-weight', 'bold')
          .style('fill', '#fff')
          .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.7)')
          .text(d => d.name.length > 10 ? d.name.substring(0, 10) + '...' : d.name);

      // Ajouter les tooltips
      const tooltip = d3.select('body').append('div')
          .attr('class', 'tooltip')
          .style('position', 'absolute')
          .style('visibility', 'hidden')
          .style('background-color', 'rgba(0, 0, 0, 0.8)')
          .style('color', 'white')
          .style('padding', '10px')
          .style('border-radius', '5px')
          .style('font-size', '12px')
          .style('z-index', '1000');

      node.on('mouseover', function(event, d) {
          tooltip.style('visibility', 'visible')
              .html(`
                  <strong>${d.name}</strong><br>
                  Tests: ${d.total_tests}<br>
                  Taux de réussite: ${d.success_rate}%<br>
                  <div style="margin-top: 5px;">
                      <span style="color: #10b981;">✓ ${d.passed_count}</span> |
                      <span style="color: #ef4444;">✗ ${d.failed_count}</span> |
                      <span style="color: #f59e0b;">⊝ ${d.skipped_count}</span>
                  </div>
              `);

          // Mettre en évidence le nœud
          d3.select(this).select('circle').style('stroke-width', 5);
      })
      .on('mousemove', function(event) {
          tooltip.style('top', (event.pageY - 10) + 'px')
              .style('left', (event.pageX + 10) + 'px');
      })
      .on('mouseout', function() {
          tooltip.style('visibility', 'hidden');
          d3.select(this).select('circle').style('stroke-width', 3);
      })
      .on('click', function(event, d) {
          window.location.href = `/tests/?tags=${d.id}`;
      });

      // Mettre à jour les positions à chaque tick avec arrêt automatique
      let tickCount = 0;
      simulation.on('tick', () => {
          link
              .attr('x1', d => d.source.x)
              .attr('y1', d => d.source.y)
              .attr('x2', d => d.target.x)
              .attr('y2', d => d.target.y);

          node.attr('transform', d => `translate(${d.x},${d.y})`);

          // Arrêter la simulation après quelques ticks pour éviter l'animation visible
          tickCount++;
          if (tickCount === 30) { // Réduit à 30 ticks pour un calcul rapide
              simulation.stop(); // Arrêter la simulation
              saveInitialPositions();
          }
      });

      // Fonction pour ajuster le zoom automatiquement
      function fitToViewport() {
          // Calculer les limites des nœuds
          const padding = 50; // Marge autour du graphique
          let minX = d3.min(nodes, d => d.x - d.radius);
          let maxX = d3.max(nodes, d => d.x + d.radius);
          let minY = d3.min(nodes, d => d.y - d.radius);
          let maxY = d3.max(nodes, d => d.y + d.radius);

          // Calculer les dimensions nécessaires
          const contentWidth = maxX - minX + 2 * padding;
          const contentHeight = maxY - minY + 2 * padding;

          // Calculer le facteur de zoom pour tout afficher
          const scaleX = width / contentWidth;
          const scaleY = height / contentHeight;
          const scale = Math.min(scaleX, scaleY, 1); // Ne pas zoomer au-delà de 100%

          // Calculer la translation pour centrer
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          const translateX = width / 2 - centerX * scale;
          const translateY = height / 2 - centerY * scale;

          // Appliquer la transformation avec animation
          svg.transition()
              .duration(1000)
              .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
      }

      // Variables pour la modal
      let modalSvg, modalG, modalZoom, modalSimulation;
      let modalNodes, modalLinks;

      // Fonction pour ouvrir la modal plein écran
      function openFullscreenModal() {
          const modal = document.getElementById('fullscreen-modal');
          modal.classList.remove('hidden');

          // Attendre que la modal soit affichée pour calculer les bonnes dimensions
          setTimeout(() => {
              const modalContainer = document.getElementById('tags-network-chart-modal');

              // Calculer les dimensions de la modal après affichage
              const modalWidth = modalContainer.clientWidth;
              const modalHeight = modalContainer.clientHeight;

              // Nettoyer le conteneur modal
              d3.select('#tags-network-chart-modal').selectAll('*').remove();

              // Créer le SVG pour la modal
              modalSvg = d3.select('#tags-network-chart-modal')
                  .append('svg')
                  .attr('width', modalWidth)
                  .attr('height', modalHeight);

              // Créer un groupe pour le zoom
              modalG = modalSvg.append('g');

              // Copier les données avec le même algorithme optimisé pour la modal
              modalNodes = sortedNodes.map((d, i) => {
                  let x, y;

                  // Même algorithme de placement optimisé, adapté aux dimensions de la modal
                  const connectivity = nodeConnectivity.get(d.id);
                  const totalNodes = sortedNodes.length;

                  if (i === 0) {
                      // Le nœud le plus connecté au centre
                      x = modalWidth / 2;
                      y = modalHeight / 2;
                  } else if (i <= 3 && totalNodes > 4) {
                      // Les 3 suivants en cercle proche du centre
                      const angle = ((i - 1) / 3) * 2 * Math.PI;
                      const radius = Math.min(modalWidth, modalHeight) / 10;
                      x = modalWidth / 2 + Math.cos(angle) * radius;
                      y = modalHeight / 2 + Math.sin(angle) * radius;
                  } else {
                      // Les autres en cercles concentriques selon leur connectivité
                      const remainingNodes = totalNodes - 4;
                      const nodeIndex = i - 4;
                      const connectivityRatio = connectivity.count / Math.max(...Array.from(nodeConnectivity.values()).map(c => c.count));

                      // Rayon basé sur la connectivité (moins connecté = plus loin)
                      const baseRadius = Math.min(modalWidth, modalHeight) / 8;
                      const maxRadius = Math.min(modalWidth, modalHeight) / 4;
                      const radius = baseRadius + (maxRadius - baseRadius) * (1 - connectivityRatio);

                      // Angle distribué pour éviter les superpositions
                      const angle = (nodeIndex / Math.max(remainingNodes, 1)) * 2 * Math.PI;

                      // Ajouter une petite variation aléatoire pour éviter l'alignement parfait
                      const angleVariation = (Math.random() - 0.5) * 0.3;
                      const radiusVariation = (Math.random() - 0.5) * 30;

                      x = modalWidth / 2 + Math.cos(angle + angleVariation) * (radius + radiusVariation);
                      y = modalHeight / 2 + Math.sin(angle + angleVariation) * (radius + radiusVariation);
                  }

                  return {
                      id: d.id,
                      name: d.name,
                      color: d.color,
                      total_tests: d.total_tests,
                      passed_count: d.passed_count,
                      failed_count: d.failed_count,
                      skipped_count: d.skipped_count,
                      flaky_count: d.flaky_count,
                      success_rate: d.success_rate,
                      radius: radiusScale(d.total_tests) * 1.5, // Plus gros dans la modal
                      x: x,
                      y: y,
                      connectivity: connectivity.count,
                      importance: connectivity.count * 2 + connectivity.totalWeight + d.total_tests
                  };
              });

              modalLinks = linksData.map(d => ({
                  source: d.source,
                  target: d.target,
                  value: d.value,
                  strength: linkStrengthScale(d.value)
              }));

              // Créer la simulation optimisée pour la modal
              modalSimulation = d3.forceSimulation(modalNodes)
                  .force('link', d3.forceLink(modalLinks).id(d => d.id)
                      .strength(d => {
                          // Même logique optimisée pour la modal
                          const baseStrength = d.strength;
                          const sourceNode = modalNodes.find(n => n.id === d.source.id || n.id === d.source);
                          const targetNode = modalNodes.find(n => n.id === d.target.id || n.id === d.target);
                          if (sourceNode && targetNode) {
                              const connectivityFactor = 1 - (sourceNode.connectivity + targetNode.connectivity) / 20;
                              return baseStrength * Math.max(connectivityFactor, 0.1);
                          }
                          return baseStrength;
                      })
                      .distance(d => {
                          const sourceNode = modalNodes.find(n => n.id === d.source.id || n.id === d.source);
                          const targetNode = modalNodes.find(n => n.id === d.target.id || n.id === d.target);
                          if (sourceNode && targetNode) {
                              const avgRadius = (sourceNode.radius + targetNode.radius) / 2;
                              const connectivityBonus = (sourceNode.connectivity + targetNode.connectivity) * 8;
                              return avgRadius * 3 + connectivityBonus + 50;
                          }
                          return 80;
                      })
                  )
                  .force('charge', d3.forceManyBody()
                      .strength(d => {
                          const baseStrength = -1200;
                          const connectivityMultiplier = 1 + d.connectivity * 0.1;
                          const sizeMultiplier = 1 + d.radius / 80;
                          return baseStrength * connectivityMultiplier * sizeMultiplier;
                      })
                  )
                  .force('center', d3.forceCenter(modalWidth / 2, modalHeight / 2).strength(0.1))
                  .force('collision', d3.forceCollide()
                      .radius(d => d.radius + 25 + d.connectivity * 3)
                      .strength(0.8)
                  )
                  .force('radial', d3.forceRadial()
                      .radius(d => {
                          const maxImportance = Math.max(...modalNodes.map(n => n.importance));
                          const importanceRatio = d.importance / maxImportance;
                          const minRadius = Math.min(modalWidth, modalHeight) / 10;
                          const maxRadius = Math.min(modalWidth, modalHeight) / 4;
                          return minRadius + (maxRadius - minRadius) * (1 - importanceRatio);
                      })
                      .x(modalWidth / 2)
                      .y(modalHeight / 2)
                      .strength(0.2)
                  );

              // Dessiner les liens pour la modal
              const modalLink = modalG.append('g')
                  .selectAll('line')
                  .data(modalLinks)
                  .enter()
                  .append('line')
                  .attr('stroke', '#999')
                  .attr('stroke-opacity', 0.6)
                  .attr('stroke-width', d => Math.sqrt(d.value) + 2);

              // Créer les groupes pour les nœuds de la modal
              const modalNode = modalG.append('g')
                  .selectAll('g')
                  .data(modalNodes)
                  .enter()
                  .append('g')
                  .attr('class', 'node')
                  .style('cursor', 'pointer')
                  .call(d3.drag()
                      .on('start', modalDragstarted)
                      .on('drag', modalDragged)
                      .on('end', modalDragended));

              // Dessiner les cercles pour la modal
              modalNode.append('circle')
                  .attr('r', d => d.radius)
                  .attr('fill', d => d.color)
                  .attr('stroke', '#fff')
                  .attr('stroke-width', 4)
                  .style('filter', 'drop-shadow(3px 3px 6px rgba(0,0,0,0.2))');

              // Ajouter les labels pour la modal
              modalNode.append('text')
                  .attr('text-anchor', 'middle')
                  .attr('dy', '0.35em')
                  .style('font-size', d => Math.min(d.radius / 3, 16) + 'px')
                  .style('font-weight', 'bold')
                  .style('fill', '#fff')
                  .style('text-shadow', '2px 2px 4px rgba(0,0,0,0.8)')
                  .text(d => d.name.length > 15 ? d.name.substring(0, 15) + '...' : d.name);

              // Ajouter les interactions pour la modal
              modalNode.on('mouseover', function(event, d) {
                  tooltip.style('visibility', 'visible')
                      .html(`
                          <strong>${d.name}</strong><br>
                          Tests: ${d.total_tests}<br>
                          Taux de réussite: ${d.success_rate}%<br>
                          <div style="margin-top: 5px;">
                              <span style="color: #10b981;">✓ ${d.passed_count}</span> |
                              <span style="color: #ef4444;">✗ ${d.failed_count}</span> |
                              <span style="color: #f59e0b;">⊝ ${d.skipped_count}</span> |
                              <span style="color: #f97316;">⚠ ${d.flaky_count}</span>
                          </div>
                      `);
                  d3.select(this).select('circle').style('stroke-width', 6);
              })
              .on('mousemove', function(event) {
                  tooltip.style('top', (event.pageY - 10) + 'px')
                      .style('left', (event.pageX + 10) + 'px');
              })
              .on('mouseout', function() {
                  tooltip.style('visibility', 'hidden');
                  d3.select(this).select('circle').style('stroke-width', 4);
              })
              .on('click', function(event, d) {
                  window.location.href = `/tests/?tags=${d.id}`;
              });

              // Mettre à jour les positions dans la modal avec arrêt automatique
              let modalTickCount = 0;
              modalSimulation.on('tick', () => {
                  modalLink
                      .attr('x1', d => d.source.x)
                      .attr('y1', d => d.source.y)
                      .attr('x2', d => d.target.x)
                      .attr('y2', d => d.target.y);

                  modalNode.attr('transform', d => `translate(${d.x},${d.y})`);

                  // Arrêter la simulation de la modal après quelques ticks
                  modalTickCount++;
                  if (modalTickCount === 30) {
                      modalSimulation.stop();
                  }
              });

              // Ajouter le zoom pour la modal
              modalZoom = d3.zoom()
                  .scaleExtent([0.3, 4])
                  .on('zoom', function(event) {
                      modalG.attr('transform', event.transform);
                      const resetBtn = document.getElementById('modal-reset-view-btn');
                      if (event.transform.k !== 1 || event.transform.x !== 0 || event.transform.y !== 0) {
                          resetBtn.classList.remove('hidden');
                      } else {
                          resetBtn.classList.add('hidden');
                      }
                  });

              modalSvg.call(modalZoom);

              // Gérer les boutons de contrôle de la modal
              setupModalControls();

          }, 100); // Attendre 100ms pour que la modal soit complètement affichée
      }

      // Fonctions de drag pour la modal - déplacement sans affecter les autres bulles
      function modalDragstarted(event, d) {
          // Ne pas redémarrer la simulation pour éviter de bouger les autres bulles
          d.fx = d.x;
          d.fy = d.y;
      }

      function modalDragged(event, d) {
          // Mettre à jour seulement la position de la bulle déplacée
          d.fx = event.x;
          d.fy = event.y;
          d.x = event.x;
          d.y = event.y;

          // Mettre à jour visuellement seulement cette bulle
          d3.select(event.sourceEvent.target.parentNode).attr('transform', `translate(${d.x},${d.y})`);

          // Mettre à jour les liens connectés à cette bulle dans la modal
          const modalLink = modalG.selectAll('line');
          modalLink.filter(l => l.source.id === d.id || l.target.id === d.id)
              .attr('x1', l => l.source.x)
              .attr('y1', l => l.source.y)
              .attr('x2', l => l.target.x)
              .attr('y2', l => l.target.y);
      }

      function modalDragended(event, d) {
          // Libérer la position fixe mais sans redémarrer la simulation globale
          d.fx = null;
          d.fy = null;
      }

      // Configuration des contrôles de la modal
      let modalControlsSetup = false;
      function setupModalControls() {
          if (modalControlsSetup) return; // Éviter la double initialisation
          modalControlsSetup = true;

          document.getElementById('modal-zoom-in-btn').addEventListener('click', function() {
              if (modalSvg && modalZoom) {
                  modalSvg.transition()
                      .duration(300)
                      .call(modalZoom.scaleBy, 1.5);
              }
          });

          document.getElementById('modal-zoom-out-btn').addEventListener('click', function() {
              if (modalSvg && modalZoom) {
                  modalSvg.transition()
                      .duration(300)
                      .call(modalZoom.scaleBy, 1 / 1.5);
              }
          });

          document.getElementById('modal-reset-view-btn').addEventListener('click', function() {
              if (modalSvg && modalZoom) {
                  modalSvg.transition()
                      .duration(750)
                      .call(modalZoom.transform, d3.zoomIdentity);
                  this.classList.add('hidden');
              }
          });

          document.getElementById('close-modal-btn').addEventListener('click', function() {
              closeFullscreenModal();
          });

          // Gérer la fermeture avec Échap (une seule fois)
          document.addEventListener('keydown', handleEscapeKey);
      }

      function handleEscapeKey(event) {
          if (event.key === 'Escape') {
              const modal = document.getElementById('fullscreen-modal');
              if (!modal.classList.contains('hidden')) {
                  closeFullscreenModal();
              }
          }
      }

      // Fonction pour fermer la modal
      function closeFullscreenModal() {
          const modal = document.getElementById('fullscreen-modal');
          modal.classList.add('hidden');

          // Nettoyer les ressources
          if (modalSimulation) {
              modalSimulation.stop();
              modalSimulation = null;
          }

          // Nettoyer les variables
          modalSvg = null;
          modalG = null;
          modalZoom = null;
          modalNodes = null;
          modalLinks = null;

          // Nettoyer le DOM
          d3.select('#tags-network-chart-modal').selectAll('*').remove();

          // Cacher le bouton reset si visible
          document.getElementById('modal-reset-view-btn').classList.add('hidden');
      }

      // Fonctions de drag - déplacement sans affecter les autres bulles
      function dragstarted(event, d) {
          // Ne pas redémarrer la simulation pour éviter de bouger les autres bulles
          // Fixer uniquement la position du nœud en cours de déplacement
          d.fx = d.x;
          d.fy = d.y;
          d.startX = d.x; // Sauvegarder la position initiale
          d.startY = d.y;
      }

      function dragged(event, d) {
          // Mettre à jour seulement la position de la bulle déplacée
          d.fx = event.x;
          d.fy = event.y;
          d.x = event.x;
          d.y = event.y;

          // Mettre à jour visuellement seulement cette bulle
          d3.select(event.sourceEvent.target.parentNode).attr('transform', `translate(${d.x},${d.y})`);

          // Mettre à jour les liens connectés à cette bulle
          link.filter(l => l.source.id === d.id || l.target.id === d.id)
              .attr('x1', l => l.source.x)
              .attr('y1', l => l.source.y)
              .attr('x2', l => l.target.x)
              .attr('y2', l => l.target.y);
      }

      function dragended(event, d) {
          // Libérer la position fixe mais sans redémarrer la simulation globale
          d.fx = null;
          d.fy = null;

          // Vérifier si des nœuds ont été déplacés significativement
          const threshold = 50; // pixels
          let nodesMoved = false;
          nodes.forEach(node => {
              if (node.startX !== undefined && node.startY !== undefined) {
                  const distance = Math.sqrt(
                      Math.pow(node.x - node.startX, 2) +
                      Math.pow(node.y - node.startY, 2)
                  );
                  if (distance > threshold) {
                      nodesMoved = true;
                  }
              }
          });

          // Afficher le bouton de reset si des nœuds ont été déplacés
          if (nodesMoved) {
              document.getElementById('reset-view-btn').classList.remove('hidden');
          }
      }

      // Ajouter le zoom
      const zoom = d3.zoom()
          .scaleExtent([0.5, 3])
          .on('zoom', function(event) {
              g.attr('transform', event.transform);
              // Afficher le bouton de reset si on n'est pas à la position initiale
              const resetBtn = document.getElementById('reset-view-btn');
              if (event.transform.k !== 1 || event.transform.x !== 0 || event.transform.y !== 0) {
                  resetBtn.classList.remove('hidden');
              } else {
                  resetBtn.classList.add('hidden');
              }
          });

      svg.call(zoom);

      // Gérer les boutons de contrôle
      document.getElementById('zoom-in-btn').addEventListener('click', function() {
          svg.transition()
              .duration(300)
              .call(zoom.scaleBy, 1.5);
      });

      document.getElementById('zoom-out-btn').addEventListener('click', function() {
          svg.transition()
              .duration(300)
              .call(zoom.scaleBy, 1 / 1.5);
      });

      document.getElementById('fullscreen-btn').addEventListener('click', function() {
          openFullscreenModal();
      });

      document.getElementById('reset-view-btn').addEventListener('click', function() {
          // Remettre le zoom à zéro
          svg.transition()
              .duration(750)
              .call(zoom.transform, d3.zoomIdentity);

          // Restaurer les positions initiales des nœuds
          if (initialPositions.size > 0) {
              nodes.forEach(node => {
                  const initialPos = initialPositions.get(node.id);
                  if (initialPos) {
                      node.fx = initialPos.x;
                      node.fy = initialPos.y;
                      node.x = initialPos.x;
                      node.y = initialPos.y;
                  }
                  delete node.startX;
                  delete node.startY;
              });

              // Redémarrer la simulation avec une alpha faible pour converger rapidement
              simulation
                  .alpha(0.1)
                  .alphaTarget(0)
                  .restart();

              // Après stabilisation, libérer les positions fixes
              setTimeout(() => {
                  nodes.forEach(node => {
                      node.fx = null;
                      node.fy = null;
                  });
              }, 500);
          } else {
              // Si pas de positions initiales sauvegardées, redémarrer normalement
              nodes.forEach(node => {
                  node.fx = null;
                  node.fy = null;
                  delete node.startX;
                  delete node.startY;
              });

              simulation
                  .alpha(1)
                  .alphaTarget(0)
                  .restart();
          }

          // Cacher le bouton
          this.classList.add('hidden');
      });

      // Remplir la légende
      const legend = document.getElementById('tags-legend');
      tagsData.forEach(tag => {
          const legendItem = document.createElement('div');
          legendItem.className = 'flex items-center justify-between p-2 bg-white rounded border';
          legendItem.innerHTML = `
              <div class="flex items-center">
                  <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${tag.color};"></div>
                  <span class="font-medium text-sm">${tag.name}</span>
              </div>
              <div class="text-xs text-gray-600">
                  ${tag.total_tests} test${tag.total_tests > 1 ? 's' : ''} (${tag.success_rate}%)
              </div>
          `;
          legend.appendChild(legendItem);
      });

  }); // Fermeture de la fonction document.addEventListener
</script>
{% endif %} {% endblock %}
